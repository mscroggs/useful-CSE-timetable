<html>
<head>
<link rel="apple-touch-icon" sizes="57x57" href="apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="manifest" href="manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">

<title>Useful CSE timetable</title>
<style type='text/css'>
a.star {text-decoration:none;font-size:150%}
.header-links a {display:inline-block;padding:10px}
.header-links a,.header-links a:link,.header-links a:visited,.header-links a:active {color:blue;text-decoration:none}
.header-links a:hover {color:blue;text-decoration:underline}
</style>
<script type='text/javascript' src='fave.js?v=2023-02-27-02'></script>

</head>
<body>
<div class='header-links'>
<a href='index.html'>Personal timetable</a>
<a href='speakers.html'>List of speakers</a>
<a href='titles.html'>List of talk titles</a>
<a href='sync.html'>Copy favourites to another device</a>
</div>
<div class='header-links'>
<a href='https://meetings.siam.org/program.cfm?CONFCODE=cse23' target='new'><small>Official conference programme</small></a>
<a href='https://raw.githubusercontent.com/mscroggs/useful-CSE-timetable/json/talks.json' target='new'><small>Talks in JSON format</small></a>
<a href='https://github.com/mscroggs/useful-CSE-timetable/' target='new'><small>GitHub</small></a>
</div>
<h1>SIAM CSE 2023</h1>


<h2>Performance Engineering and Applications - Part I of II</h2><div class='index-talk' id='talk462' style='display:block'><a href='javascript:toggle_star(462)' class='star'><span class='star462'>&star;</span></a> <b>9:45 AM&ndash;10:00 AM (D404)</b> Georg Hager, Performance Engineering in CSE: A Bird's Eye View <span id='bitlink-426'><small><a href='javascript:show_bit(426)'>&#x25BC; Show talk info &#x25BC;</a></small></span><span id='bit-426' style='display:none'><small><a href='javascript:hide_bit(426)'>&#x25B2; Hide talk info &#x25B2;</a></small><div style='padding:20px'><b>Performance Engineering in CSE: A Bird's Eye View</b><br />Georg Hager<br />Wednesday, March 1 9:45 AM&ndash;10:00 AM<br />This is the 1st talk in <a href='session-103.html'>Performance Engineering and Applications - Part I of II</a> (9:45 AM&ndash;11:25 AM)<br />D404<br /><br /><small>Performance Engineering (PE) in Computational Science and Engineering (CSE) has two goals: First, to understand the performance bottlenecks of a code, and second, to use this insight to apply changes that will improve performance. There is a wide spectrum of workflows and tools in this field, but all have in common that the whole PE process is iterative, yielding  improvements until some preset target is achieved or some other criterion is met (such as "I've done enough").    
This talk gives an overview of methods, tools, and metrics that are in use for Performance Engineering in CSE. Some, but not all PE activities are well defined in the sense of a prescribed workflow, and we try to accommodate that by building mostly on examples from performance research, performance tools development, and performance-aware application development. Whichever strategy is applied, performance patterns can help to build a better understanding of the performance issues at hand. We will describe typical performance patterns and how they can serve to accelerate the PE process.    
  </small><br /><br /><small><a href='https://meetings.siam.org/sess/dsp_programsess.cfm?SESSIONCODE=75374' target='new'>More information on the conference website</a></small></div></span></div><div class='index-talk' id='talk463' style='display:block'><a href='javascript:toggle_star(463)' class='star'><span class='star463'>&star;</span></a> <b>10:05 AM&ndash;10:20 AM (D404)</b> Jonas Thies, Performance of Low-Rank Tensor Algorithms <span id='bitlink-427'><small><a href='javascript:show_bit(427)'>&#x25BC; Show talk info &#x25BC;</a></small></span><span id='bit-427' style='display:none'><small><a href='javascript:hide_bit(427)'>&#x25B2; Hide talk info &#x25B2;</a></small><div style='padding:20px'><b>Performance of Low-Rank Tensor Algorithms</b><br />Jonas Thies<br />Wednesday, March 1 10:05 AM&ndash;10:20 AM<br />This is the 2nd talk in <a href='session-103.html'>Performance Engineering and Applications - Part I of II</a> (9:45 AM&ndash;11:25 AM)<br />D404<br /><br /><small>We discuss low-rank tensor algorithms and in particular algorithms for the tensor-train (TT) format (known as MPS in computational physics).  We focus on the required building blocks and model their node-level performance on modern multi-core CPUs.  More specifically, we consider the lossy compression of large dense data (TT-SVD), as well as linear solvers in TT format (TT-MALS, TT-GMRES).  For the data compression, we derive the optimal roofline runtime for the complete algorithm based on the two main building blocks in an optimized implementation:  Q-less TSQR and tall-skinny matrix-matrix multiplication.  For the low-rank linear solvers, we categorize the different kinds of building blocks according to performance characteristics and show possible performance optimizations.  While all required tensor operations can be mapped onto standard BLAS/LAPACK routines theoretically, faster implementations need specific performance optimizations:  These include (1) avoiding costly singular-value decompositions (SVDs),  and (2) employing special fused operations for sequences of memory-bound tensor-contractions and reshaping operations,  as well as (3) tracking properties of tensors such as orthogonalities.  We show the effect of the different optimizations and compare the runtime of our implementation with other tensor libraries.    </small><br /><br /><small><a href='https://meetings.siam.org/sess/dsp_programsess.cfm?SESSIONCODE=75374' target='new'>More information on the conference website</a></small></div></span></div><div class='index-talk' id='talk464' style='display:block'><a href='javascript:toggle_star(464)' class='star'><span class='star464'>&star;</span></a> <b>10:25 AM&ndash;10:40 AM (D404)</b> Eva Siegmann, Porting An Ocean Modeling Application to Fujitsu A64FX <span id='bitlink-428'><small><a href='javascript:show_bit(428)'>&#x25BC; Show talk info &#x25BC;</a></small></span><span id='bit-428' style='display:none'><small><a href='javascript:hide_bit(428)'>&#x25B2; Hide talk info &#x25B2;</a></small><div style='padding:20px'><b>Porting An Ocean Modeling Application to Fujitsu A64FX</b><br />Eva Siegmann<br />Wednesday, March 1 10:25 AM&ndash;10:40 AM<br />This is the 3rd talk in <a href='session-103.html'>Performance Engineering and Applications - Part I of II</a> (9:45 AM&ndash;11:25 AM)<br />D404<br /><br /><small>In this presentation we report our preliminary efforts in porting ROMS (Regional Ocean Modeling System) to Fujitsu A64FX. ROMS is a free-surface, terrain-following, primitive equations ocean model widely used by the scientific community for a diverse range of applications. The arm-based Fujitsu A64FX processor developed by Fujitsu and RIKEN is used in Fugaku, which until June 2022 has been the fastest machine worldwide for two years. Its main features of SVE, HBM and being power efficient makes it unique in the world of HPC. ROMS is one of few Ookami user codes that demonstrate performance parity of A64FX compared to mainstream architectures. This implies a huge power advantage as the power usage on A64FX is around 2-3 times less than on Intel.    </small><br /><br /><small><a href='https://meetings.siam.org/sess/dsp_programsess.cfm?SESSIONCODE=75374' target='new'>More information on the conference website</a></small></div></span></div><div class='index-talk' id='talk465' style='display:block'><a href='javascript:toggle_star(465)' class='star'><span class='star465'>&star;</span></a> <b>10:45 AM&ndash;11:00 AM (D404)</b> Andreas Hadjigeorgiou, Optimizing Wavefield-Modelling for Seismic Inversion Applications on HPC Architectures <span id='bitlink-429'><small><a href='javascript:show_bit(429)'>&#x25BC; Show talk info &#x25BC;</a></small></span><span id='bit-429' style='display:none'><small><a href='javascript:hide_bit(429)'>&#x25B2; Hide talk info &#x25B2;</a></small><div style='padding:20px'><b>Optimizing Wavefield-Modelling for Seismic Inversion Applications on HPC Architectures</b><br />Andreas Hadjigeorgiou<br />Wednesday, March 1 10:45 AM&ndash;11:00 AM<br />This is the 4th talk in <a href='session-103.html'>Performance Engineering and Applications - Part I of II</a> (9:45 AM&ndash;11:25 AM)<br />D404<br /><br /><small>The seismic imaging process aims at creating an image of the subsurface layer interfaces by acoustic reflection measurements along the surface of the Earth. In many of such algorithms so-called one-way depth propagation of acoustic wavefields is the core mechanism, in order to reconstruct the acoustic waves as they would have occurred inside the Earth. Such process allows finding out where the reflections have occurred and with which strength. The computational efficiency of these applications resolves to the efficiency of the underlying wavefield propagator. An algorithm that has been proposed in the literature is the Phase-Shift Plus Interpolation, which handles wave propagation through inhomogeneous media by phase-shift propagation with a set of reference velocities - each assuming a local homogeneous medium - and a spatial interpolation mechanism. One objective of our work is to deliver a performance-portable wavefield propagation solver for various computer architectures. Our approach to this is to provide the algorithm through an architecture-agnostic interface, developed based on C++ templates, which at compile-time resolves to an architecture-specific back-end. We develop the OpenMP back-end for threaded parallelism on CPUs, CUDA for acceleration on Nvidia GPUs, and HIP for porting CUDA to AMD GPUs. To evaluate the efficiency of the implementations we use the roofline model. In this presentation we will describe our implementation and show some benchmark results.    </small><br /><br /><small><a href='https://meetings.siam.org/sess/dsp_programsess.cfm?SESSIONCODE=75374' target='new'>More information on the conference website</a></small></div></span></div><div class='index-talk' id='talk466' style='display:block'><a href='javascript:toggle_star(466)' class='star'><span class='star466'>&star;</span></a> <b>11:05 AM&ndash;11:20 AM (D404)</b> Kevin N. Gott, Stream Triggered Communications for Mesh Applications on GPU Systems <span id='bitlink-430'><small><a href='javascript:show_bit(430)'>&#x25BC; Show talk info &#x25BC;</a></small></span><span id='bit-430' style='display:none'><small><a href='javascript:hide_bit(430)'>&#x25B2; Hide talk info &#x25B2;</a></small><div style='padding:20px'><b>Stream Triggered Communications for Mesh Applications on GPU Systems</b><br />Kevin N. Gott<br />Wednesday, March 1 11:05 AM&ndash;11:20 AM<br />This is the 5th talk in <a href='session-103.html'>Performance Engineering and Applications - Part I of II</a> (9:45 AM&ndash;11:25 AM)<br />D404<br /><br /><small>With the advancement of GPGPUs as powerful and reliable scientific computing tools, communication performance has become increasingly important. Due to both the relative increase in the amount of time being spent in communications as well as the often synchronous nature of these calls, improving the performance of communication kernels a high-value target for HPC simulation performance improvement. One new technology that may be able to improve performance of HPC communication kernels is stream triggered communication.    
This talk will give an overview of our investigation into stream triggered communication options and their application in AMReX. We will present the results from a toy halo exchange code used to identify the optimal algorithmic motifs and compare current stream triggered options, including MPI-X and MPI-ACX. We’ll then present the results of adding stream-triggered communications to AMReX’s FillBoundary halo exchange operation, using the optimal algorithm. Finally, higher level application improvements that are enabled by stream-triggered communications will be discussed, such as redesigning stream interactions between the CPU and GPU to eliminate synchronizations and maximize GPU uptime.  </small><br /><br /><small><a href='https://meetings.siam.org/sess/dsp_programsess.cfm?SESSIONCODE=75374' target='new'>More information on the conference website</a></small></div></span></div>

</body>
</html>
