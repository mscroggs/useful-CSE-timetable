<html>
<head>
<link rel="apple-touch-icon" sizes="57x57" href="apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="manifest" href="manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">

<title>Useful CSE timetable</title>
<style type='text/css'>
a.star {text-decoration:none;font-size:150%}
.header-links a {display:inline-block;padding:10px}
.header-links a,.header-links a:link,.header-links a:visited,.header-links a:active {color:blue;text-decoration:none}
.header-links a:hover {color:blue;text-decoration:underline}
</style>
<script type='text/javascript' src='fave.js?v=2023-02-27-02'></script>

</head>
<body>
<div class='header-links'>
<a href='index.html'>Personal timetable</a>
<a href='speakers.html'>List of speakers</a>
<a href='titles.html'>List of talk titles</a>
<a href='sync.html'>Copy favourites to another device</a>
</div>
<div class='header-links'>
<a href='https://meetings.siam.org/program.cfm?CONFCODE=cse23' target='new'><small>Official conference programme</small></a>
<a href='https://raw.githubusercontent.com/mscroggs/useful-CSE-timetable/json/talks.json' target='new'><small>Talks in JSON format</small></a>
<a href='https://github.com/mscroggs/useful-CSE-timetable/' target='new'><small>GitHub</small></a>
</div>
<h1>SIAM CSE 2023</h1>


<h2>Emerging Techniques for Scalable Graph Processing - Part II of II</h2><div class='index-talk' id='talk1825' style='display:block'><a href='javascript:toggle_star(1825)' class='star'><span class='star1825'>&star;</span></a> <b>1:50 PM&ndash;2:05 PM (D402)</b> Alex Pothen, Approximation As a Paradigm for Designing Parallel Graph Algorithms <span id='bitlink-1670'><small><a href='javascript:show_bit(1670)'>&#x25BC; Show talk info &#x25BC;</a></small></span><span id='bit-1670' style='display:none'><small><a href='javascript:hide_bit(1670)'>&#x25B2; Hide talk info &#x25B2;</a></small><div style='padding:20px'><b>Approximation As a Paradigm for Designing Parallel Graph Algorithms</b><br />Alex Pothen<br />Monday, February 27 1:50 PM&ndash;2:05 PM<br />This is the 1st talk in <a href='session-402.html'>Emerging Techniques for Scalable Graph Processing - Part II of II</a> (1:50 PM&ndash;3:30 PM)<br />D402<br /><br /><small>We describe a paradigm for designing parallel algorithms by approximation techniques. Instead of solving a problem exactly, for which parallel algorithms may not exist, we seek a solution with provable approximation guarantees. Furthermore, we design these algorithms to be concurrent. Â We discuss several matching and edge cover problems for which such algorithms have been designed, and describe their use in solving problems in sparse matrix computations and load balancing problems in quantum chemistry.  </small><br /><br /><small><a href='https://meetings.siam.org/sess/dsp_programsess.cfm?SESSIONCODE=75882' target='new'>More information on the conference website</a></small></div></span></div><div class='index-talk' id='talk1826' style='display:block'><a href='javascript:toggle_star(1826)' class='star'><span class='star1826'>&star;</span></a> <b>2:10 PM&ndash;2:25 PM (D402)</b> Mina Sun, How Good Is Approximately Solving Graph Problems As Width-Constrained Positive Linear Programs in Parallel? <span id='bitlink-1671'><small><a href='javascript:show_bit(1671)'>&#x25BC; Show talk info &#x25BC;</a></small></span><span id='bit-1671' style='display:none'><small><a href='javascript:hide_bit(1671)'>&#x25B2; Hide talk info &#x25B2;</a></small><div style='padding:20px'><b>How Good Is Approximately Solving Graph Problems As Width-Constrained Positive Linear Programs in Parallel?</b><br />Mina Sun<br />Monday, February 27 2:10 PM&ndash;2:25 PM<br />This is the 2nd talk in <a href='session-402.html'>Emerging Techniques for Scalable Graph Processing - Part II of II</a> (1:50 PM&ndash;3:30 PM)<br />D402<br /><br /><small>Graph problems, like those of s-t path and densest subgraph, are frequently employed to solve a wide range of applied problems. A number of these graph problems can be expressed either approximately or exactly as a width-constrained positive linear program (LP), and this formulation may also admit further approximation by using low-hop emulators or hopsets. Furthermore, many of these problems can be solved with a $(1+\epsilon)$ approximation factor in a highly parallel way. In recent years, novel algorithms using these techniques have been developed and analyzed theoretically, but their practical implications are not well understood in the literature.    
In this talk, we will explore some of the practical implications of these algorithms for large-scale distributed graph problems. In particular, we have implemented and analyzed the parallel $(1+\epsilon)$-approximate with $\tilde{O}(n)$ parallel depth s-t path algorithm from Andoni, Stein, and Zhong (STOC 2020) and the Multiplicative Weights Update (MWU) method from Mahoney et. al (ICALP 2016) that finds a $(1+\epsilon)$-approximate solution to a positive LP in $\tilde{O}(\epsilon^{-3})$ time (this is a joint work with Caleb Ju and Serif Yesil.) We show that, for certain types of problems, the novel methods trades vastly superior performance for a small decrease in accuracy, while for others the gains are insubstantial. We also present some implementation-specific enhancements.  </small><br /><br /><small><a href='https://meetings.siam.org/sess/dsp_programsess.cfm?SESSIONCODE=75882' target='new'>More information on the conference website</a></small></div></span></div><div class='index-talk' id='talk1827' style='display:block'><a href='javascript:toggle_star(1827)' class='star'><span class='star1827'>&star;</span></a> <b>2:30 PM&ndash;2:45 PM (D402)</b> David Tench, GraphZeppelin: Linear Sketching for Dynamic Graph Connectivity <span id='bitlink-1672'><small><a href='javascript:show_bit(1672)'>&#x25BC; Show talk info &#x25BC;</a></small></span><span id='bit-1672' style='display:none'><small><a href='javascript:hide_bit(1672)'>&#x25B2; Hide talk info &#x25B2;</a></small><div style='padding:20px'><b>GraphZeppelin: Linear Sketching for Dynamic Graph Connectivity</b><br />David Tench<br />Monday, February 27 2:30 PM&ndash;2:45 PM<br />This is the 3rd talk in <a href='session-402.html'>Emerging Techniques for Scalable Graph Processing - Part II of II</a> (1:50 PM&ndash;3:30 PM)<br />D402<br /><br /><small>Existing graph stream processing systems must store the graph explicitly in RAM which limits the scale of graphs they can process. The graph semi-streaming literature offers algorithms which avoid this limitation via linear sketching data structures that use small (sublinear) space, but these algorithms have not seen use in practice to date. In this talk I will present GraphZeppelin, a streaming graph system for computing the connected components of a dynamically changing graph. I will show how GraphZeppelin uses linear sketching to efficiently process graphs too large to store explicitly in RAM, and why existing linear sketching algorithms for this and other graph problems fall short in practice. I will show how these sketching techniques scale incredibly well in the the distributed setting, with provably near-optimally low network communication overhead.  Finally, I will discuss what these results mean for the semi-streaming model and what is required for linear sketching algorithms to be practical.    
    </small><br /><br /><small><a href='https://meetings.siam.org/sess/dsp_programsess.cfm?SESSIONCODE=75882' target='new'>More information on the conference website</a></small></div></span></div><div class='index-talk' id='talk1828' style='display:block'><a href='javascript:toggle_star(1828)' class='star'><span class='star1828'>&star;</span></a> <b>2:50 PM&ndash;3:05 PM (D402)</b> Albert Jan Yzelman, Algebraic and Humble Programming <span id='bitlink-1673'><small><a href='javascript:show_bit(1673)'>&#x25BC; Show talk info &#x25BC;</a></small></span><span id='bit-1673' style='display:none'><small><a href='javascript:hide_bit(1673)'>&#x25B2; Hide talk info &#x25B2;</a></small><div style='padding:20px'><b>Algebraic and Humble Programming</b><br />Albert Jan Yzelman<br />Monday, February 27 2:50 PM&ndash;3:05 PM<br />This is the 4th talk in <a href='session-402.html'>Emerging Techniques for Scalable Graph Processing - Part II of II</a> (1:50 PM&ndash;3:30 PM)<br />D402<br /><br /><small>We first recall the concept of a "humble programmer" and contrast it to that of a "hero programmer". Classically, the former focuses on achieving high productivity, while the latter focuses on extracting peak performance on a given system. Given that both the complexity of programming novel architectures increases, and that the trend of producing heterogeneous systems that combine multiple such complex architectures is becoming normal, humble programming that achieves scalable performance close to peak on a variety of architectures is becoming a necessity-- yet remains challenging.  This talk introduces the free and open-source Algebraic Programming (ALP) paradigm as such a candidate solution, and ALP/GraphBLAS specifically. Here, programmers must annotate their code with algebraic information, which the compiler then exploits in optimization, the detection of programmer errors, and unscalable behaviour. Beyond sparse linear algebra, we additionally extend ALP to cover dense linear algebra as well as vertex-centric programming. Finally, we demonstrate the ALP platform's efficiency and scalability, thus arriving at a humble programming model for both numerical linear algebra, graph algorithms, and beyond.  </small><br /><br /><small><a href='https://meetings.siam.org/sess/dsp_programsess.cfm?SESSIONCODE=75882' target='new'>More information on the conference website</a></small></div></span></div><div class='index-talk' id='talk1829' style='display:block'><a href='javascript:toggle_star(1829)' class='star'><span class='star1829'>&star;</span></a> <b>3:10 PM&ndash;3:25 PM (D402)</b> Vishnuvarthan Rajagopal, Intelligent Rendezvous Point Selection for Improving Network Performance in SDIoT <span id='bitlink-1674'><small><a href='javascript:show_bit(1674)'>&#x25BC; Show talk info &#x25BC;</a></small></span><span id='bit-1674' style='display:none'><small><a href='javascript:hide_bit(1674)'>&#x25B2; Hide talk info &#x25B2;</a></small><div style='padding:20px'><b>Intelligent Rendezvous Point Selection for Improving Network Performance in SDIoT</b><br />Vishnuvarthan Rajagopal<br />Monday, February 27 3:10 PM&ndash;3:25 PM<br />This is the 5th talk in <a href='session-402.html'>Emerging Techniques for Scalable Graph Processing - Part II of II</a> (1:50 PM&ndash;3:30 PM)<br />D402<br /><br /><small>Software-defined networking is a critical enabler of the Internet of Things. The wireless sensor network is a network of specialized embedded devices that have limited power and storage which provide sensing services to the Software Defined Internet of Things (SDIoT). The radio unit in a sensor node consumes the most energy, hence, an efficient routing strategy is essential to enhance the network lifetime. Most IoT-based WSN environments suffer from traditional clustering and routing methods, which cause data loss, energy hole issues, and sensor premature death. If it did not use adaptive learning methodologies and continued to use the existing protocol in IoT environment, the network's performance would degrade. In order to overcome these issues, a clustering algorithm based on double Q-learning algorithm is proposed to improve network lifetime and decrease delay in the IoT with uncertain communication links. The simulation findings demonstrate that it outperforms existing clustering and routing algorithms, particularly in terms of performance parameters such as network lifetime, data collection delay and learning rate.    </small><br /><br /><small><a href='https://meetings.siam.org/sess/dsp_programsess.cfm?SESSIONCODE=75882' target='new'>More information on the conference website</a></small></div></span></div>

</body>
</html>
