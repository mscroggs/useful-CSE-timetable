<html>
<head>
<link rel="apple-touch-icon" sizes="57x57" href="apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="manifest" href="manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">

<title>Useful CSE timetable</title>
<style type='text/css'>
a.star {text-decoration:none;font-size:150%}
.header-links a {display:inline-block;padding:10px}
.header-links a,.header-links a:link,.header-links a:visited,.header-links a:active {color:blue;text-decoration:none}
.header-links a:hover {color:blue;text-decoration:underline}
</style>
<script type='text/javascript' src='fave.js?v=2023-02-27-02'></script>

</head>
<body>
<div class='header-links'>
<a href='index.html'>Personal timetable</a>
<a href='speakers.html'>List of speakers</a>
<a href='titles.html'>List of talk titles</a>
<a href='sync.html'>Copy favourites to another device</a>
</div>
<div class='header-links'>
<a href='https://meetings.siam.org/program.cfm?CONFCODE=cse23' target='new'><small>Official conference programme</small></a>
<a href='https://raw.githubusercontent.com/mscroggs/useful-CSE-timetable/json/talks.json' target='new'><small>Talks in JSON format</small></a>
<a href='https://github.com/mscroggs/useful-CSE-timetable/' target='new'><small>GitHub</small></a>
</div>
<h1>SIAM CSE 2023</h1>


<h2>From Math to Code: Domain-Specific Programming Abstractions, Languages, and Frameworks - Part II of II</h2><div class='index-talk' id='talk1087' style='display:block'><a href='javascript:toggle_star(1087)' class='star'><span class='star1087'>&star;</span></a> <b>1:50 PM&ndash;2:05 PM (G104)</b> Paolo Bientinesi, High-Performance Matrix Computations: We Need More Than Fast Libraries <span id='bitlink-1003'><small><a href='javascript:show_bit(1003)'>&#x25BC; Show talk info &#x25BC;</a></small></span><span id='bit-1003' style='display:none'><small><a href='javascript:hide_bit(1003)'>&#x25B2; Hide talk info &#x25B2;</a></small><div style='padding:20px'><b>High-Performance Matrix Computations: We Need More Than Fast Libraries</b><br />Paolo Bientinesi<br />Wednesday, March 1 1:50 PM&ndash;2:05 PM<br />This is the 1st talk in <a href='session-239.html'>From Math to Code: Domain-Specific Programming Abstractions, Languages, and Frameworks - Part II of II</a> (1:50 PM&ndash;3:30 PM)<br />G104<br /><br /><small>As matrix computations are the bottleneck in countless workflows and applications, many excellent libraries have been developed. These offer a broad range of computational building blocks, optimized for different aspects such as computing platform, problem size, precision, and matrix properties. However, in spite of the quality of such libraries, we observe that end users are increasingly less likely to use them, at least directly. In fact, realistic workflows are significantly more complex than the functionality of the kernels offered in such libraries, and the intelligent decomposition of a workflow in terms of a set of available kernels is in itself a challenging task. We refer to this task as "Linear Algebra Mapping Problem" (LAMP). In practice, the problem is often circumvented by adopting high-level languages such as Matlab, Python, and R, or C++ (in combination with libraries such as Armadillo or Eigen), which offer a convenient high-level syntax for matrix computations, thus boosting user productivity; by contrast, these languages are still immature with respect to the solution of the LAMP, and in terms of performance they suffer from vastly suboptimal choices. In a nutshell: High-performance libraries are a necessary, but not sufficient component for high-performance matrix computations.   </small><br /><br /><small><a href='https://meetings.siam.org/sess/dsp_programsess.cfm?SESSIONCODE=75564' target='new'>More information on the conference website</a></small></div></span></div><div class='index-talk' id='talk1088' style='display:block'><a href='javascript:toggle_star(1088)' class='star'><span class='star1088'>&star;</span></a> <b>2:10 PM&ndash;2:25 PM (G104)</b> Hong Ge, High Performance Domain-Specific Language for Probabilistic Programming <span id='bitlink-1004'><small><a href='javascript:show_bit(1004)'>&#x25BC; Show talk info &#x25BC;</a></small></span><span id='bit-1004' style='display:none'><small><a href='javascript:hide_bit(1004)'>&#x25B2; Hide talk info &#x25B2;</a></small><div style='padding:20px'><b>High Performance Domain-Specific Language for Probabilistic Programming</b><br />Hong Ge<br />Wednesday, March 1 2:10 PM&ndash;2:25 PM<br />This is the 2nd talk in <a href='session-239.html'>From Math to Code: Domain-Specific Programming Abstractions, Languages, and Frameworks - Part II of II</a> (1:50 PM&ndash;3:30 PM)<br />G104<br /><br /><small>In this talk, we will go through the design and implementation of the DynamicPPL library (the modelling language for Turing.jl). DynamicPPL is a high-performance, general-purpose domain-specific language for probabilistic programming. It allows applied scientists to specify probabilistic models using an intuitive syntax. The same model program can be transformed into many forms corresponding to various statistical operations, such as sampling from the prior, evaluating the prior density, evaluating the log-likelihoods and evaluating the joint log density. These different model forms significantly reduce boiler-and-plate code for statistical programming, enhance communication, and accelerate the speed of iterating modelling workflows. DynamicPPL has been used in some critical settings such as Covid-19 modelling, and pharmaceutical modelling.     </small><br /><br /><small><a href='https://meetings.siam.org/sess/dsp_programsess.cfm?SESSIONCODE=75564' target='new'>More information on the conference website</a></small></div></span></div><div class='index-talk' id='talk1089' style='display:block'><a href='javascript:toggle_star(1089)' class='star'><span class='star1089'>&star;</span></a> <b>2:30 PM&ndash;2:45 PM (G104)</b> Shoaib Kamil, Halide: Growing Dopsies from Research Projects to Industrial Adoption <span id='bitlink-1005'><small><a href='javascript:show_bit(1005)'>&#x25BC; Show talk info &#x25BC;</a></small></span><span id='bit-1005' style='display:none'><small><a href='javascript:hide_bit(1005)'>&#x25B2; Hide talk info &#x25B2;</a></small><div style='padding:20px'><b>Halide: Growing Dopsies from Research Projects to Industrial Adoption</b><br />Shoaib Kamil<br />Wednesday, March 1 2:30 PM&ndash;2:45 PM<br />This is the 3rd talk in <a href='session-239.html'>From Math to Code: Domain-Specific Programming Abstractions, Languages, and Frameworks - Part II of II</a> (1:50 PM&ndash;3:30 PM)<br />G104<br /><br /><small>While research into domain-specific programming systems ("dopsies") continues to expand, only a few of these systems have matured enough to find adoption outside of small research communities.  One notable exception is Halide [Ragan-Kelley et al, SIGGRAPH 2012; Ragan-Kelley et al, PLDI 2013], a programming language and compiler for dense computations on images and tensors.  Used in multiple shipping products, including Adobe Photoshop and Google Photos, Halide presents an interesting case study of a dopsy used for production while still forming the basis of continuing research projects.  This talk outlines the history of Halide's adoption, the design decisions that enable this adoption, and the challenges that come with simultaneously supporting multiple production use cases across multiple (sometimes competing) companies.    
  </small><br /><br /><small><a href='https://meetings.siam.org/sess/dsp_programsess.cfm?SESSIONCODE=75564' target='new'>More information on the conference website</a></small></div></span></div><div class='index-talk' id='talk1090' style='display:block'><a href='javascript:toggle_star(1090)' class='star'><span class='star1090'>&star;</span></a> <b>2:50 PM&ndash;3:05 PM (G104)</b> Mary Hall, Data Layout in Domain-Specific Compilers and Code Generators <span id='bitlink-1006'><small><a href='javascript:show_bit(1006)'>&#x25BC; Show talk info &#x25BC;</a></small></span><span id='bit-1006' style='display:none'><small><a href='javascript:hide_bit(1006)'>&#x25B2; Hide talk info &#x25B2;</a></small><div style='padding:20px'><b>Data Layout in Domain-Specific Compilers and Code Generators</b><br />Mary Hall<br />Wednesday, March 1 2:50 PM&ndash;3:05 PM<br />This is the 4th talk in <a href='session-239.html'>From Math to Code: Domain-Specific Programming Abstractions, Languages, and Frameworks - Part II of II</a> (1:50 PM&ndash;3:30 PM)<br />G104<br /><br /><small>Domain-specific compiler technology bridges between the domain scientist's expression of their problem and architecture-specific code generation.  In this talk, we will describe how domain-specific code generation is facilitated by a data layout description that is co-optimized with the computation.  We will examine how to generate performance-portable code with data layouts designed to minimize data movement for the application domain.  </small><br /><br /><small><a href='https://meetings.siam.org/sess/dsp_programsess.cfm?SESSIONCODE=75564' target='new'>More information on the conference website</a></small></div></span></div><div class='index-talk' id='talk1091' style='display:block'><a href='javascript:toggle_star(1091)' class='star'><span class='star1091'>&star;</span></a> <b>3:10 PM&ndash;3:25 PM (G104)</b> Pawel Radtke, An Extension of C++ with a Memory-Centric Specification Language for HPC <span id='bitlink-1007'><small><a href='javascript:show_bit(1007)'>&#x25BC; Show talk info &#x25BC;</a></small></span><span id='bit-1007' style='display:none'><small><a href='javascript:hide_bit(1007)'>&#x25B2; Hide talk info &#x25B2;</a></small><div style='padding:20px'><b>An Extension of C++ with a Memory-Centric Specification Language for HPC</b><br />Pawel Radtke<br />Wednesday, March 1 3:10 PM&ndash;3:25 PM<br />This is the 5th talk in <a href='session-239.html'>From Math to Code: Domain-Specific Programming Abstractions, Languages, and Frameworks - Part II of II</a> (1:50 PM&ndash;3:30 PM)<br />G104<br /><br /><small>
The C programming language and its cousins such as C++ lean towards a memory-inefficient storage of structs: developers have to commit to one, invariant data model unless they rearrange the data structures manually, the natural data structure for object-based models is array of structs, and the compiler has to insert bits such that individual attributes align with byte boundaries. Furthermore, the language provides no native support for data exchange via MPI and precision formats beyond the IEEE standard. We propose a language extension based upon C++ attributes which give developers more fine-grained control over the memory implementation of data structures: numerical types tailored to their value ranges with bit-level granularity, automatic bit packing of boolean and enumerable fields, customisable reduced-precision storage types for floating-point data, as well as local declarative conversions between Array-of-Structures to Structure-of-Arrays layouts for "for" and "for-each" loops. Finally, we propose attribute-driven MPI mappings generation for arbitrary data types, including the new data types that we offer.     
  Our proposals are realised via a compiler-based approach by extending the Clang/LLVM compiler toolchain. In the presentation we demonstrate the capabilities of our extensions, as well as show the performance impacts on a set of large-scale smoothed-particle hydrodynamics simulation (SPH) codes.    </small><br /><br /><small><a href='https://meetings.siam.org/sess/dsp_programsess.cfm?SESSIONCODE=75564' target='new'>More information on the conference website</a></small></div></span></div>

</body>
</html>
